% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predictive_moments.R
\name{predictive_moments}
\alias{predictive_moments}
\title{Analytical computation of predictive moments for an \code{hhh4} model}
\usage{
predictive_moments(
  hhh4Obj,
  t_condition,
  lgt,
  return_Sigma = FALSE,
  return_cov_array = FALSE,
  return_mu_decomposed = FALSE,
  return_M = FALSE
)
}
\arguments{
\item{hhh4Obj}{an \code{hhh4} object}

\item{t_condition}{the index of the week on which to condition the
path forecast, i.e. an integer between 1 and \code{nrow(hhh4Obj$stsObj@observed)}.
If you need forecasts beyond the end of your observed time series you need to
artificially prolong the \code{sts} object used by adding \code{NA} values
to the end.}

\item{lgt}{the length of the path forecast, i.e. 52 for forecasting
an entire season when using weekly data}

\item{return_Sigma}{logical: should the entire variance-covariance
matrix of the forecast be returned? defaults to \code{FALSE} in
order to save storage.}

\item{return_cov_array}{logical: should an array with week-wise
covariance matrices be returned?}

\item{return_mu_decomposed}{logical: should an array with the
predictive means decomposed into the different components be returned?}

\item{return_M}{logical: should the matrix M containing the predictive
first and (un-centered) second moments be returned?}
}
\value{
An object of class \code{stationary_moments_hhh4} containing
the following components:
\itemize{
  \item{\code{mu_matrix}} A matrix containing the predictive means.
  Each row corresponds
  to a time period and each column to a unit.
  \item{\code{var_matrix}} A matrix containing the predictive variances.
  \item{\code{cov_array}} An array containing time period-wise
  variance-covariance matrices.
  \item{\code{mu_vector}} as \code{mu_matrix}, but flattened into a vector.
  \item{\code{Sigma}} a large covariance matrix for all elements
  of the prediction
  (corresponding to \code{mu_vector})
  \item{\code{M}} a matrix containing predictive means and (un-centered)
   second moments,
  specifically E(c(1, X)%*%t(c(1, X))) where X contains all counts that
   shall be forecasted.
  Important in the internal calculation, accessible mainly for
  de-bugging purposes.
  \item{\code{mu_decomposed}} an array with the same number of rows
   and columns as
  \code{mu_matrix}, but three layers corresponding to the contributions
   of the three
  components to the means
  \item{\code{start}} the index (in the original \code{sts} object) of
   the first time
  period of the prediction
  \item{\code{freq}} the length of a cycle
  \item{\code{n_units}} the number of units covered in the prediction
  \item{\code{timepoints}} the timepoints covered by the prediction etc.
  \item{\code{timepoints}} as \code{timepoints}, but calendar time
  rather than indices
  \item{\code{condition}} A matrix containing the realizations for
  the conditioning time period (or periods)
  \item{\code{realizations_matrix}} A matrix containing the realizations
  that have materialized in the
  period covered by the prediction.
  \item{\code{type}} \code{"predictive"}; to distinguish from stationary
   moments.
  \item{\code{has_temporal_structure}} does the object still have the
   original temporal structure? can
  be set to \code{FALSE} when aggregated using \code{aggregate_prediction}.
  }
}
\description{
This functions calculates the predictive mean vector and covariance
matrix for a path forecast from an \code{hhh4} model.
}
\examples{
data("salmonella.agona")
# convert old "disProg" to new "sts" data class:
salmonella <- disProg2sts(salmonella.agona)
control_salmonella <- list(end = list(f = addSeason2formula(~ 1), lag = 1),
                           ar = list(f = addSeason2formula(~ 1), lag = 1),
                           family = "NegBinM", subset = 6:250)
fit_salmonella <- hhh4_lag(salmonella, control_salmonella) # fit model
# obtain prediction:
pred_mom <- predictive_moments(fit_salmonella, t_condition = 250, lgt = 52)
plot(fit_salmonella)
fanplot_prediction(pred_mom, add = TRUE) # add fan plot
}
